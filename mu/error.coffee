# Public Domain (-) 2014 The Wikifactory Authors.
# See the Wikifactory UNLICENSE file for details.

defmod 'µ', (µ, root) ->

  {Error, Object} = root
  {captureStackTrace} = Error

  newError = (name, defaultMessage) ->
    CustomError = (message) ->
      err = @
      if !(err instanceof CustomError)
        return new CustomError(message)
      err.name = name
      err.message = if typeof message is 'string' then message else defaultMessage
      if captureStackTrace
        captureStackTrace err, CustomError
      return
    CustomError:: = Object.create Error::,
      constructor:
        value: CustomError
    return CustomError

  µ.newError = newError

  defError = (name, defaultMessage) ->
    µ[name] = newError name, defaultMessage
    return

  defError 'KeyError', 'key not found'
  defError 'StopFlow', 'flow was stopped'
  defError 'Timeout', 'timeout error'
  defError 'ValueError', 'invalid value'

  _ = µ._

  _.tryErr = tryError =
    e: {}

  _.tryFn = (fn) ->
    # We define a JavaScript block here to avoid the unneccessary error
    # assignment generated by CoffeeScript.
    #
    # See https://github.com/jashkenas/coffee-script/issues/3434 for more info.
    `try {
        return fn();
    } catch (_err) {
        tryError.e = _err;
        return tryError;
    }`
    return

  _.tryFn1 = (fn, arg) ->
    `try {
        return fn(arg);
    } catch (_err) {
        tryError.e = _err;
        return tryError;
    }`
    return

  _.tryFn2 = (fn, arg1, arg2) ->
    `try {
        return fn(arg1, arg2);
    } catch (_err) {
        tryError.e = _err;
        return tryError;
    }`
    return

  _.tryCall = (ctx, meth, arg) ->
    `try {
        return meth.call(obj, arg);
    } catch (_err) {
        tryError.e = _err;
        return tryError;
    }`
    return

  _.tryApply = (ctx, fn, arg) ->
    `try {
        return fn.apply(null, arg);
    } catch (_err) {
        tryError.e = _err;
        return tryError;
    }`
    return

  return
